
<!DOCTYPE HTML>
<html lang="en" class="polkadot" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0026: Sassafras Consensus Protocol - Polkadot Fellowship RFCs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="An online book of RFCs approved or proposed within the Polkadot Fellowship.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/polkadot.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "polkadot" : "polkadot";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('polkadot')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Approved</li><li class="chapter-item expanded "><a href="../approved/0001-agile-coretime.html">RFC-1: Agile Coretime</a></li><li class="chapter-item expanded "><a href="../approved/0005-coretime-interface.html">RFC-5: Coretime Interface</a></li><li class="chapter-item expanded "><a href="../approved/0007-system-collator-selection.html">RFC-0007: System Collator Selection</a></li><li class="chapter-item expanded "><a href="../approved/0008-parachain-bootnodes-dht.html">RFC-0008: Store parachain bootnodes in relay chain DHT</a></li><li class="chapter-item expanded "><a href="../approved/0012-process-for-adding-new-collectives.html">RFC-0012: Process for Adding New System Collectives</a></li><li class="chapter-item expanded "><a href="../approved/0014-improve-locking-mechanism-for-parachains.html">RFC-0014: Improve locking mechanism for parachains</a></li><li class="chapter-item expanded "><a href="../approved/0022-adopt-encointer-runtime.html">RFC-0022: Adopt Encointer Runtime</a></li><li class="chapter-item expanded "><a href="../approved/0032-minimal-relay.html">RFC-0032: Minimal Relay</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Newly Proposed</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Proposed</li><li class="chapter-item expanded "><a href="../proposed/0004-remove-unnecessary-allocator-usage.html">RFC-0004: Remove the host-side runtime memory allocator</a></li><li class="chapter-item expanded "><a href="../proposed/000x-assethub.html">RFC-0000: Lowering NFT Deposits on Polkadot and Kusama Asset Hubs</a></li><li class="chapter-item expanded "><a href="../proposed/0010-burn-coretime-revenue.html">RFC-0010: Burn Coretime Revenue</a></li><li class="chapter-item expanded "><a href="../proposed/0020-treasurer-track-confirmation-period-duration-modification.html">RFC-0020: Treasurer Track Confirmation Period Duration Modification</a></li><li class="chapter-item expanded "><a href="../proposed/0026-sassafras-consensus.html" class="active">RFC-0026: Sassafras Consensus Protocol</a></li><li class="chapter-item expanded "><a href="../proposed/0034-xcm-absolute-location-account-derivation.html">RFC-34: XCM Absolute Location Account Derivation</a></li><li class="chapter-item expanded "><a href="../proposed/0035-conviction-voting-delegation-modifications.html"> RFC-0035: Conviction Voting Delegation Modifications</a></li><li class="chapter-item expanded "><a href="../proposed/0042-extrinsics-state-version.html">RFC-0042: Add System version that replaces StateVersion on RuntimeVersion</a></li><li class="chapter-item expanded "><a href="../proposed/0043-storage-proof-size-hostfunction.html">RFC-0043: Introduce storage_proof_size Host Function for Improved Parachain Block Utilization</a></li><li class="chapter-item expanded "><a href="../proposed/0044-rent-based-registration.html">RFC-0044: Rent based registration model</a></li><li class="chapter-item expanded "><a href="../proposed/0046-metadata-for-offline-signers.html">RFC-0000: Metadata for offline signers</a></li><li class="chapter-item expanded "><a href="../proposed/0047-assignment-of-availability-chunks.html">RFC-0047: Assignment of availability chunks to validators</a></li><li class="chapter-item expanded "><a href="../proposed/0048-session-keys-runtime-api.html">RFC-0048: Generate ownership proof for SessionKeys</a></li><li class="chapter-item expanded "><a href="../proposed/0050-fellowship-salaries.html">RFC-0050: Fellowship Salaries</a></li><li class="chapter-item expanded "><a href="../proposed/0054-remove-heap-pages.html">RFC-0054: Remove the concept of "heap pages" from the client</a></li><li class="chapter-item expanded "><a href="../proposed/0056-one-transaction-per-notification.html">RFC-0056: Enforce only one transaction per notification</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Stale</li><li class="chapter-item expanded "><a href="../stale/0006-dynamic-pricing-for-bulk-coretime-sales.html">RFC-0006: Dynamic Pricing for Bulk Coretime Sales</a></li><li class="chapter-item expanded "><a href="../stale/0009-improved-net-light-client-requests.html">RFC-0009: Improved light client requests networking protocol</a></li><li class="chapter-item expanded "><a href="../stale/0011-add-new-path-to-account-creation-on-asset-hubs.html">RFC-0011: Add New Path to Account Creation on Asset Hubs</a></li><li class="chapter-item expanded "><a href="../stale/0013-prepare-blockbuilder-and-core-runtime-apis-for-mbms.html">RFC-0013: Prepare BlockBuilder and Core runtime APIs for MBMs</a></li><li class="chapter-item expanded "><a href="../stale/0015-market-design-revisit.html">RFC-0015: Market Design Revisit</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="polkadot">Polkadot</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polkadot Fellowship RFCs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/polkadot-fellows/RFCs/pull/26">(source)</a></p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#rfc-0026-sassafras-consensus-protocol">RFC-0026: Sassafras Consensus Protocol</a>
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#1-motivation">1. Motivation</a>
<ul>
<li><a href="#11-relevance-to-implementors">1.1. Relevance to Implementors</a></li>
<li><a href="#12-supporting-sassafras-for-polkadot">1.2. Supporting Sassafras for Polkadot</a></li>
</ul>
</li>
<li><a href="#2-stakeholders">2. Stakeholders</a>
<ul>
<li><a href="#21-developers-of-blockchains">2.1. Developers of Blockchains</a></li>
<li><a href="#22-contributors-to-the-polkadot-ecosystem">2.2. Contributors to the Polkadot Ecosystem</a></li>
</ul>
</li>
<li><a href="#3-notation-and-convention">3. Notation and Convention</a>
<ul>
<li><a href="#31-data-structures-definitions-and-encoding">3.1. Data Structures Definitions and Encoding</a></li>
<li><a href="#32-pseudo-code">3.2. Pseudo-Code</a></li>
<li><a href="#33-incremental-introduction-of-types-and-functions">3.3. Incremental Introduction of Types and Functions</a></li>
</ul>
</li>
<li><a href="#4-protocol-introduction">4. Protocol Introduction</a>
<ul>
<li><a href="#41-submission-of-candidate-tickets">4.1. Submission of Candidate Tickets</a></li>
<li><a href="#42-validation-of-candidate-tickets">4.2. Validation of Candidate Tickets</a></li>
<li><a href="#43-tickets-and-slots-binding">4.3. Tickets and Slots Binding</a></li>
<li><a href="#44-claim-of-ticket-ownership">4.4. Claim of Ticket Ownership</a></li>
<li><a href="#45-validation-of-ticket-ownership">4.5. Validation of Ticket Ownership</a></li>
</ul>
</li>
<li><a href="#5-bandersnatch-vrfs-cryptographic-primitives">5. Bandersnatch VRFs Cryptographic Primitives</a>
<ul>
<li><a href="#51-vrf-input">5.1. VRF Input</a></li>
<li><a href="#52-vrf-output">5.2. VRF Output</a></li>
<li><a href="#53-vrf-signature-data">5.3. VRF Signature Data</a></li>
<li><a href="#54-vrf-signature">5.4. VRF Signature</a></li>
</ul>
</li>
<li><a href="#6-sassafras-protocol">6. Sassafras Protocol</a>
<ul>
<li><a href="#61-epochs-first-block">6.1. Epoch's First Block</a></li>
<li><a href="#62-creation-and-submission-of-candidate-tickets">6.2. Creation and Submission of Candidate Tickets</a></li>
<li><a href="#63-validation-of-candidate-tickets">6.3. Validation of candidate tickets</a></li>
<li><a href="#64-ticket-slot-assignment">6.4. Ticket-Slot assignment</a></li>
<li><a href="#65-claim-of-ticket-ownership-during-block-production">6.5. Claim of ticket ownership during block production</a></li>
<li><a href="#66-validation-of-the-claim-during-block-verification">6.6. Validation of the claim during block verification</a></li>
<li><a href="#661-primary-claim-method-verification">6.6.1. Primary Claim Method Verification</a></li>
<li><a href="#67-randomness-accumulator">6.7. Randomness Accumulator</a></li>
</ul>
</li>
<li><a href="#7-drawbacks">7. Drawbacks</a></li>
<li><a href="#8-testing-security-and-privacy">8. Testing, Security, and Privacy</a></li>
<li><a href="#9-performance-ergonomics-and-compatibility">9. Performance, Ergonomics, and Compatibility</a>
<ul>
<li><a href="#91-performance">9.1. Performance</a></li>
<li><a href="#92-ergonomics">9.2. Ergonomics</a></li>
<li><a href="#93-compatibility">9.3. Compatibility</a></li>
</ul>
</li>
<li><a href="#10-prior-art-and-references">10. Prior Art and References</a></li>
<li><a href="#11-unresolved-questions">11. Unresolved Questions</a></li>
<li><a href="#12-future-directions-and-related-material">12. Future Directions and Related Material</a>
<ul>
<li><a href="#121-interactions-with-the-runtime">12.1. Interactions with the Runtime</a></li>
<li><a href="#122-deployment-strategies">12.2. Deployment Strategies</a></li>
<li><a href="#123-zk-snark-srs-initialization-ceremony">12.3. ZK-SNARK SRS Initialization Ceremony.</a></li>
<li><a href="#124-anonymous-submission-of-tickets">12.4. Anonymous Submission of Tickets.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Table of Contents</strong></p>
<!-- toc -->
<h1 id="rfc-0026-sassafras-consensus-protocol"><a class="header" href="#rfc-0026-sassafras-consensus-protocol">RFC-0026: Sassafras Consensus Protocol</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Start Date</strong></td><td>September 06, 2023</td></tr>
<tr><td><strong>Description</strong></td><td>Sassafras consensus protocol description and structures</td></tr>
<tr><td><strong>Authors</strong></td><td>Davide Galassi</td></tr>
</tbody></table>
</div>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Sassafras is a novel consensus protocol designed to address the recurring
fork-related challenges encountered in other lottery-based protocols.</p>
<p>Sassafras aims to establish a unique association between each epoch's slots and
the validators, ensuring that there is one and only one validator per slot.</p>
<p>The protocol ensures the anonymity of the validator associated to a slot until
the slot is not claimed at block production time.</p>
<h2 id="1-motivation"><a class="header" href="#1-motivation">1. Motivation</a></h2>
<p>Sassafras Protocol has been extensively documented in a comprehensive <a href="https://eprint.iacr.org/2023/031.pdf">research
paper</a> from the <a href="https://web3.foundation">Web3 foundation</a>
research team.</p>
<p>This RFC serves the purpose of conveying most of the essential implementation
details that are crucial for interoperability and clarifying aspects left open
for implementation discretion.</p>
<h3 id="11-relevance-to-implementors"><a class="header" href="#11-relevance-to-implementors">1.1. Relevance to Implementors</a></h3>
<p>This RFC focuses on providing implementors with the necessary insights into the
protocol's operation.</p>
<p>To avoid ambiguities and interoperability issues, this document takes precedence
over the research paper in cases where discrepancies arise between the two.</p>
<h3 id="12-supporting-sassafras-for-polkadot"><a class="header" href="#12-supporting-sassafras-for-polkadot">1.2. Supporting Sassafras for Polkadot</a></h3>
<p>In addition to fostering interoperability, another objective of this RFC is to
facilitate the implementation of Sassafras within the Polkadot ecosystem. While
the specifics of deployment mechanics are beyond the scope of this document, it
paves the way for integrating Sassafras into the Polkadot network.</p>
<h2 id="2-stakeholders"><a class="header" href="#2-stakeholders">2. Stakeholders</a></h2>
<h3 id="21-developers-of-blockchains"><a class="header" href="#21-developers-of-blockchains">2.1. Developers of Blockchains</a></h3>
<p>Developers responsible for creating blockchains who intend to leverage the
benefits offered by the Sassafras Protocol.</p>
<h3 id="22-contributors-to-the-polkadot-ecosystem"><a class="header" href="#22-contributors-to-the-polkadot-ecosystem">2.2. Contributors to the Polkadot Ecosystem</a></h3>
<p>Developers contributing to the Polkadot ecosystem, both relay-chain and para-chains.
The protocol will have a central role in the next generation Polkadot relay chain
block authoring system.</p>
<h2 id="3-notation-and-convention"><a class="header" href="#3-notation-and-convention">3. Notation and Convention</a></h2>
<p>This section outlines the notation and conventions used throughout the document
to ensure clarity and consistency.</p>
<h3 id="31-data-structures-definitions-and-encoding"><a class="header" href="#31-data-structures-definitions-and-encoding">3.1. Data Structures Definitions and Encoding</a></h3>
<p>Data structures are primarily defined using <a href="https://en.wikipedia.org/wiki/ASN.1">ASN.1</a>,
with a few exceptions:</p>
<ul>
<li>Integer types are not explicitly defined in ASN.1 and in the context of
this document <code>U&lt;n&gt;</code> should be interpreted as a <code>n</code>-bit unsigned integers</li>
</ul>
<p>If no context-specific instructions are given, all types must be serialized
using <a href="https://github.com/paritytech/parity-scale-codec">SCALE</a> codec.</p>
<p>To ensure interoperability of serialized structures, the order of the single
fields is required to match the structures definitions found in this document.</p>
<h3 id="32-pseudo-code"><a class="header" href="#32-pseudo-code">3.2. Pseudo-Code</a></h3>
<p>Through this document it is advantageous to make use of code snippets as part
of the comprehensive description. These snippets shall adhere to the subsequent
conventions:</p>
<ul>
<li>
<p>For simplicity, code snippets are presented in a <em>Rust-like</em> pseudocode format.</p>
</li>
<li>
<p>The function <code>BYTES(x: T)</code> returns an <code>OCTET_STRING</code> representing the raw
byte array representation of the object <code>x</code> with type <code>T</code>.</p>
<ul>
<li>If <code>T</code> is <code>VisibleString</code> (i.e. an ASCII string): it returns the sequence
of octets of its ASCII representation.</li>
<li>If <code>T</code> is <code>U&lt;n&gt;</code>: it returns the little-endian encoding of the integer
<code>U&lt;n&gt;</code> as <code>n/8</code> octets.</li>
</ul>
</li>
<li>
<p>The function <code>U&lt;n&gt;(x: OCTET_STRING)</code> returns a <code>U&lt;n&gt;</code> interpreting <code>x</code> as
the little-endian encoding of a <code>n</code> bits unsigned integer.</p>
</li>
<li>
<p>The function <code>SCALE(x: T)</code> returns an <code>OCTET_STRING</code> representing the
<a href="https://github.com/paritytech/parity-scale-codec"><code>SCALE</code></a> encoding of
<code>x</code> with type <code>T</code>.</p>
</li>
<li>
<p>The function <code>BLAKE2(n: U32, x: OCTET_STRING)</code> returns <code>n</code> bytes of the
standard <em>blake2b</em> hash of <code>x</code> as an <code>OCTET_STRING</code>.</p>
</li>
<li>
<p>The function <code>CONCAT(x₀: OCTET_STRING, ..., xₖ: OCTET_STRING)</code> returns the
concatenation of the inputs as an <code>OCTET_STRING</code>.</p>
</li>
<li>
<p>The function <code>LENGTH(x: OCTET_STRING)</code> returns a <code>U32</code> representing the
number of octets in <code>x</code>.</p>
</li>
</ul>
<h3 id="33-incremental-introduction-of-types-and-functions"><a class="header" href="#33-incremental-introduction-of-types-and-functions">3.3. Incremental Introduction of Types and Functions</a></h3>
<p>Types and helper functions will be introduced incrementally as they become
relevant within the document's context.</p>
<p>We find this approach more agile, especially given that the set of types used is
not extensive or overly complex.</p>
<p>This incremental presentation enhances readability and comprehension.</p>
<h2 id="4-protocol-introduction"><a class="header" href="#4-protocol-introduction">4. Protocol Introduction</a></h2>
<p>Timeline is partitioned in epochs, epochs are partitioned in slots.</p>
<p>The Sassafras protocol employs a binding mechanism between validators and slots
through the use of a ticketing system.</p>
<p>The protocol can be divided into five discrete and asynchronous phases:</p>
<h3 id="41-submission-of-candidate-tickets"><a class="header" href="#41-submission-of-candidate-tickets">4.1. Submission of Candidate Tickets</a></h3>
<p>Validators generate and submit their candidate tickets to the blockchain. Each
ticket comes with an anonymous validity proof.</p>
<h3 id="42-validation-of-candidate-tickets"><a class="header" href="#42-validation-of-candidate-tickets">4.2. Validation of Candidate Tickets</a></h3>
<p>Each candidate tickets undergo a validation process for the associated validity
proof and compliance with other protocol-specific constraints.</p>
<h3 id="43-tickets-and-slots-binding"><a class="header" href="#43-tickets-and-slots-binding">4.3. Tickets and Slots Binding</a></h3>
<p>After collecting all candidate tickets, a deterministic method is employed to
uniquely associate a subset of these tickets to the next epoch slots.</p>
<h3 id="44-claim-of-ticket-ownership"><a class="header" href="#44-claim-of-ticket-ownership">4.4. Claim of Ticket Ownership</a></h3>
<p>Validators prove ownership of tickets during the block production phase. This
step establishes a secure binding between validators and their respective slots.</p>
<h3 id="45-validation-of-ticket-ownership"><a class="header" href="#45-validation-of-ticket-ownership">4.5. Validation of Ticket Ownership</a></h3>
<p>During block verification, the claims of ticket ownership are validated to
uphold the protocol's integrity.</p>
<h2 id="5-bandersnatch-vrfs-cryptographic-primitives"><a class="header" href="#5-bandersnatch-vrfs-cryptographic-primitives">5. Bandersnatch VRFs Cryptographic Primitives</a></h2>
<p>This chapter provides a high-level overview of the Bandersnatch VRF primitive as
it relates to the Sassafras protocol.</p>
<p>It's important to note that this section is not intended to serve as an
exhaustive exploration of the mathematically intensive foundations of the
cryptographic primitive. Instead, its primary purpose is to offer a concise and
comprehensible interpretation of the primitive within the context of this RFC.</p>
<p>For a more detailed understanding we recommend referring to the Ring-VRF
<a href="https://eprint.iacr.org/2023/002.pdf">research paper</a> from W3F.</p>
<h3 id="51-vrf-input"><a class="header" href="#51-vrf-input">5.1. VRF Input</a></h3>
<p>The VRF Input, denoted as <code>VrfInput</code>, is constructed by combining a domain identifier
with arbitrary data using the <code>vrf_input</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn vrf_input(domain: OCTET_STRING, buf: OCTET_STRING) -&gt; VrfInput;
<span class="boring">}</span></code></pre></pre>
<p>The specific implementation details of this function are intentionally omitted
here, you can find a complete reference implementation in the
<a href="https://github.com/w3f/ring-vrf/blob/18614458ca4cb335c88d4e710c13906a76f51e43/bandersnatch_vrfs/src/lib.rs#L57"><code>bandersnatch_vrfs</code></a> 
project.</p>
<p>Helper function to construct a <code>VrfInput</code> from a sequence of <code>data</code> items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn vrf_input_from_items(domain: OCTET_STRING, data: SEQUENCE_OF OCTET_STRING) -&gt; VrfInput {
        buf = OCTET_STRING(SIZE(0));
        for item in data {
            buf.append(item);
            buf.append(LENGTH(item) as U8);
        }
        return vrf_input(domain, buf);
    }
<span class="boring">}</span></code></pre></pre>
<p>Note that we cast the length of each item to a <code>U8</code>. In the context of the
protocol we never have to append strings longer than 255. The function is
internal and not designed to be generic.</p>
<TODO>
Or we should provide a generic one in bandersnatch primitive wrapper to be
used in other contexts? 
</TODO>
<h3 id="52-vrf-output"><a class="header" href="#52-vrf-output">5.2. VRF Output</a></h3>
<p>A <code>VrfOutput</code> in this context is computed in function of a <code>VrfInput</code> and a
<code>BandersnatchSecretKey</code>.</p>
<p>A <code>VrfOutput</code> can be created in two ways: as a standalone object or as part of a
VRF signature. In both scenarios, the resulting <code>VrfOutput</code> remains the same, but
the primary difference lies in the inclusion of a signature in the latter, which
serves to confirm its validity.</p>
<p>In practice, the <code>VrfOutput</code> is a verifiable <em>seed</em> to produce a variable number
of pseudo-random bytes. These bytes are considered valid when <code>VrfOutput</code> is
accompanied by a valid signature.</p>
<p>When constructed as a standalone object, <code>VrfOutput</code> is primarily employed
in situations where the secret key owner needs to check if the generated
pseudo-random bytes fulfill some criteria before applying the signature.</p>
<p>To facilitate the construction of <code>VrfOutput</code> from a secret key and <code>VrfInput</code>,
the following helper function is provided:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn vrf_output(secret: BandernatchSecretKey, input: VrfInput) -&gt; VrfOutput;
<span class="boring">}</span></code></pre></pre>
<p>Additionally, a helper function is provided for producing <code>len</code> bytes from
<code>VrfInput</code> and <code>VrfOutput</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn vrf_bytes(len: U32, input: VrfInput, output: VrfOuput) -&gt; OCTET_STRING;
<span class="boring">}</span></code></pre></pre>
<p>Just like the <code>VrfInput</code> support function, we have intentionally excluded the
detailed implementation of this function in this document. A reference implementation
is provided in the <code>dleq_vrfs</code> library:</p>
<ul>
<li><a href="https://github.com/w3f/ring-vrf/blob/18614458ca4cb335c88d4e710c13906a76f51e43/dleq_vrf/src/traits.rs#L75-L77"><code>vrf_output</code></a></li>
<li><a href="https://github.com/w3f/ring-vrf/blob/18614458ca4cb335c88d4e710c13906a76f51e43/dleq_vrf/src/vrf.rs#L211-L214"><code>vrf_bytes</code></a></li>
</ul>
<h3 id="53-vrf-signature-data"><a class="header" href="#53-vrf-signature-data">5.3. VRF Signature Data</a></h3>
<p>This section defines the data to be signed using the VRF primitive:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    VrfSignatureData ::= SEQUENCE {
        transcript: Transcript,
        inputs: SEQUENCE_OF VrfInput
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>transcript</code>: an <a href="https://docs.rs/ark-transcript/latest/ark_transcript/"><code>ark-transcript</code></a>
object. In practice, this is a <em>special</em> hash of some protocol-specific data
to sign which should not influence the <code>VrfOutput</code>.</li>
<li><code>inputs</code>: sequence of <code>VrfInputs</code> to be signed.</li>
</ul>
<p>To simplify the construction of a <code>VrfSignatureData</code> object, a helper function is provided:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn vrf_signature_data(
        transcript_label: OCTET_STRING,
        transcript_data: SEQUENCE_OF OCTET_STRING,
        inputs: SEQUENCE_OF VrfInput
    ) -&gt; VrfSignatureData {
        let mut transcript = Transcript::new_labeled(transcript_label);
        for data in transcript_data {
            transcript.append(data);
        }
        VrfSignatureData { transcript, inputs }
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="54-vrf-signature"><a class="header" href="#54-vrf-signature">5.4. VRF Signature</a></h3>
<p>Bandersnatch VRF offers two signature flavors:</p>
<ul>
<li><em>plain</em> signature, which is much like a traditional <em>Schnorr</em> signature,</li>
<li><em>ring</em> signature which leverages a <em>zk-SNARK</em> to allows for anonymous signatures
using a key from a predefined set of enabled keys, known as the ring.</li>
</ul>
<h4 id="541-plain-vrf-signature"><a class="header" href="#541-plain-vrf-signature">5.4.1. Plain VRF Signature</a></h4>
<p>This section describes the signature process for <code>VrfSignatureData</code> using the
plain Bandersnatch signature flavor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    PlainSignature ::= OCTET_STRING;

    VrfSignature ::= SEQUENCE {
        signature: PlainSignature,
        outputs: SEQUENCE-OF VrfOutput
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>signature</code>: the actual signature.</li>
<li><code>outputs</code>: a sequence of <code>VrfOutput</code>s corresponding to the <code>VrfInput</code>s values.</li>
</ul>
<p>Helper function to create a <code>VrfPlainSignature</code> from <code>VrfSignatureData</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    BandersnatchSecretKey ::= OCTET_STRING;

    fn vrf_sign(
        secret: BandernatchSecretKey,
        signature_data: VrfSignatureData
    ) -&gt; VrfSignature
<span class="boring">}</span></code></pre></pre>
<p>Helper function for validating the signature and returning a <code>BOOLEAN</code> value
indicating the validity of the signature.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    BandersnatchPublicKey ::= OCTET_STRING;

    fn vrf_verify(
        public: BandersnatchPublicKey,
        signature: VrfSignature
    ) -&gt; BOOLEAN;
<span class="boring">}</span></code></pre></pre>
<p>In this document, the types <code>BandersnatchSecretKey</code>, <code>BandersnatchPublicKey</code>
and <code>PlainSignature</code> are intentionally left undefined. Their definitions can be
found in the <code>bandersnatch_vrfs</code> reference implementation.</p>
<h4 id="542-ring-vrf-signature"><a class="header" href="#542-ring-vrf-signature">5.4.2. Ring VRF Signature</a></h4>
<p>This section deals with the signature process for <code>VrfSignatureData</code> using the
Bandersnatch ring signature flavor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    RingSignature ::= OCTET_STRING;

    RingVrfSignature ::= SEQUENCE {
        signature: RingSignature,
        outputs: SEQUENCE_OF VrfOutput
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>signature</code>: the actual signature.</li>
<li><code>outputs</code>: sequence of <code>VrfOutput</code> objects corresponding to the <code>VrfInput</code> values.</li>
</ul>
<p>Helper function to create a <code>RingVrfSignature</code> from <code>VrfSignatureData</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    BandersnatchRingProverKey ::= OCTET_STRING;
    
    fn ring_vrf_sign(
        secret: BandersnatchRingProverKey,
        signature_data: VrfSignatureData,
    ) -&gt; RingVrfSignature;
<span class="boring">}</span></code></pre></pre>
<p>Helper function for validating the signature and returning a <code>BOOLEAN</code>
indicating the validity of the signature (<code>True</code> if it's valid). It's important
to note that this function does not require the signer's public key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    BandersnatchRingVerifierKey ::= OCTET_STRING;

    fn ring_vrf_verify(
        verifier: BandersnatchRingVerifierKey,
        signature: RingVrfSignature,
    ) -&gt; BOOLEAN;
<span class="boring">}</span></code></pre></pre>
<p>In this document, the types <code>BandersnatchRingProverKey</code>,
<code>BandersnatchRingVerifierKey</code>, and <code>RingSignature</code> are intentionally left
undefined. Their definitions can be found in the <code>bandersnatch_vrfs</code> reference
implementation.</p>
<h2 id="6-sassafras-protocol"><a class="header" href="#6-sassafras-protocol">6. Sassafras Protocol</a></h2>
<h3 id="61-epochs-first-block"><a class="header" href="#61-epochs-first-block">6.1. Epoch's First Block</a></h3>
<p>The first block produced for epoch <code>N</code> is required to include the descriptor for
the next epoch <code>N+1</code>.</p>
<p>The descriptor for next epoch is <code>NextEpochDescriptor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    AuthorityId ::= BandersnatchPublicKey;

    Randomness ::= OCTET_STRING(SIZE(32));

    NextEpochDescriptor ::= SEQUENCE {
        randomness: Randomness,
        authorities: SEQUENCE_OF AuthorityId,
        configuration: ProtocolConfiguration OPTIONAL
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>randomness</code>: randomness value.</li>
<li><code>authorities</code>: list of authorities.</li>
<li><code>configuration</code>: optional protocol configuration.</li>
</ul>
<p>The <code>NextEpochDescriptor</code> must be <code>SCALE</code> encoded and embedded in the block
header digest log.</p>
<p>The identifier for the digest element is <code>BYTES(&quot;SASS&quot;)</code>.</p>
<p><strong>Security Consideration</strong>: Instances of <code>NextEpochDescriptor</code> are generated
through on-chain code whenever a block is identified as the first of an epoch.
Consequently, every node executing the block should verify that the descriptor
locally generated during block execution matches the one produced by the block
author, which is found in the digest data before block import.</p>
<h4 id="611-epoch-randomness"><a class="header" href="#611-epoch-randomness">6.1.1. Epoch Randomness</a></h4>
<p>Each block ships with some entropy source in the form of bandersnatch
<code>VrfOutput</code>. Per block randomness is accumulated in the protocol's on-chain
randomness accumulator <strong>after</strong> block import.</p>
<p>The exact procedure to accumulate per-block randomness is described in detail
later, in the randomness accumulator paragraph (<a href="#67-randomness-accumulator">6.7</a>).</p>
<p>Next epoch <code>randomness</code> is computed as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    next_epoch_randomness = BLAKE2(32, CONCAT(randomness_accumulator, BYTES(next_epoch_index)));
<span class="boring">}</span></code></pre></pre>
<h4 id="612-protocol-configuration"><a class="header" href="#612-protocol-configuration">6.1.2. Protocol Configuration</a></h4>
<p>The <code>ProtocolConfiguration</code> primarily influences certain checks carried out
during tickets validation. It is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ProtocolConfiguration ::= SEQUENCE {
        attempts_number: U32,
        redundancy_factor: U32
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>attempts_number</code>: max number of tickets that can be submitted by each
next epoch authority.</li>
<li><code>redundancy_factor</code>: controls the expected number of extra tickets produced
beyond <code>epoch_length</code>.</li>
</ul>
<p>The attempts number influences the anonymity of block producers. As all
published tickets have a <strong>public</strong> attempt number less than <code>attempts_number</code>,
all the tickets which share the attempt number value must belong to different
block producers, which reduces anonymity late in the epoch.</p>
<p>We do not mind <code>max_attempts &lt; epoch_length</code> though because this loss of
anonymity already becomes small when <code>attempts_number = 64</code> or <code>128</code> and larger
values requires more computation.</p>
<p>Details about how exactly these parameters drives the ticket validity
probability can be found in the section dedicated to candidate ticket validation
(<a href="#622-tickets-threshold">6.2.2</a>).</p>
<p><code>ProtocolConfiguration</code> values can be adjusted via a dedicated extrinsic which
should have origin set to <code>Root</code>. A valid configuration proposal submitted on
epoch <code>K</code> will be propagated in the <code>NextEpochDescriptor</code> at the beginning of
epoch <code>K+1</code> and will be effectively enacted on epoch <code>K+2</code>.</p>
<h4 id="613-startup-parameters"><a class="header" href="#613-startup-parameters">6.1.3. Startup Parameters</a></h4>
<p>Some parameters for first epoch (index = 0) are configurable via genesis configuration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    GenesisConfig ::= SEQUENCE {
        authorities: SEQUENCE_OF AuthorityId,
        configuration: ProtocolConfiguration OPTIONAL
    }
<span class="boring">}</span></code></pre></pre>
<p>Randomness for first epoch is set to all zeros.</p>
<p>As block #0 is locally produced by every node by processing the genesis configuration,
the first block explicitly produced by a validator for the first epoch is block #1.</p>
<p>Block #1 must embed the <code>NextEpochDescriptor</code> for next epoch. This is
constructed re-using the same values used for the first epoch.</p>
<h3 id="62-creation-and-submission-of-candidate-tickets"><a class="header" href="#62-creation-and-submission-of-candidate-tickets">6.2. Creation and Submission of Candidate Tickets</a></h3>
<p>As a shorthand notation, in this section we refer to one of the next epoch
validators as 'the validator'.</p>
<p>Upon the beginning of a new epoch <code>N</code>, the validator will construct a set of
'tickets' to be submitted on-chain. These tickets aim to secure ownership of one
or more slots in the upcoming epoch <code>N+1</code>.</p>
<p>Each validator is allowed to submit a maximum number of tickets whose value is
found in the next epoch <code>ProtocolConfiguration</code> <code>attempts_number</code> field.</p>
<p>The expected ratio between the attempts and the number of tickets which are
assigned to the next epoch slots is driven by the ticket threshold
(<a href="#622-tickets-threshold">6.2.2</a>).</p>
<p>Each ticket has an associated unique identifier, denoted as <code>TicketId</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    TicketId ::= U128
<span class="boring">}</span></code></pre></pre>
<h4 id="621-ticket-identifier-value"><a class="header" href="#621-ticket-identifier-value">6.2.1. Ticket Identifier Value</a></h4>
<p>The value of the <code>TicketId</code> is determined by the output of the Bandersnatch VRF
when using the following inputs:</p>
<ul>
<li>Next epoch randomness: <code>Randomness</code> obtained from the <code>NextEpochDescriptor</code>.</li>
<li>Next epoch index: <code>U64</code> computed as epoch start slot divided epoch duration.</li>
<li>Attempt index: <code>U32</code> value going from <code>0</code> to <code>attempts_number</code>.</li>
</ul>
<p>Let <code>next_epoch</code> be an object with the information associated to the next epoch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ticket_id_vrf_input = vrf_input_from_items(
        BYTES(&quot;sassafras-ticket-v1.0&quot;),
        [ 
            next_epoch.randomness,
            BYTES(next_epoch.epoch_index),
            BYTES(attempt_index)
        ]
    );

    ticket_id_vrf_output = vrf_output(AUTHORITY_SECRET_KEY, ticket_id_vrf_input);

    ticket_bytes = vrf_bytes(16, ticket_id_vrf_input, ticket_id_vrf_output);
    ticket_id = U128(ticket_bytes);
<span class="boring">}</span></code></pre></pre>
<h4 id="622-tickets-threshold"><a class="header" href="#622-tickets-threshold">6.2.2. Tickets Threshold</a></h4>
<p>A <code>TicketId</code> value is valid if its value is less than the ticket threshold.</p>
<pre><code>T = (r·s)/(a·v)
</code></pre>
<p>Where:</p>
<ul>
<li><code>v</code>: the number of authorities (aka validators) in the epoch</li>
<li><code>s</code>: number of slots in the epoch</li>
<li><code>r</code>: the redundancy factor</li>
<li><code>a</code>: number of attempts</li>
<li><code>T</code>: ticket threshold value (<code>0 ≤ T ≤ 1</code>)</li>
</ul>
<h5 id="6221-formula-derivation"><a class="header" href="#6221-formula-derivation">6.2.2.1 Formula Derivation</a></h5>
<p>For an epoch of <code>s</code> slots we want to have a number of tickets in expectation for
block production equal to the <code>r·s</code>.</p>
<p>We need that there is a very small probability of their being less than <code>s</code>
winning tickets, even if up to <code>1/3</code> of authorities are offline.</p>
<p>First we set the probability of a ticket winning as <code>T = (r·s)/(a·v)</code>.</p>
<p>Let <code>n</code> be the number of validators who actually participate and so <code>v·2/3 ≤ n ≤ v</code>.</p>
<p>These <code>n</code> validators make <code>a</code> attempts each, for a total of <code>a·n</code> attempts.</p>
<p>Let <code>X</code> be the random variable associated to the number of winning tickets, then
its expected value is:</p>
<pre><code>E[X] = T·a·n = (r·s·n)/v
</code></pre>
<p>By setting <code>r = 2</code>, we get</p>
<pre><code>s·4/3 ≤ E[X] ≤ s·2
</code></pre>
<p>Using <em>Bernestein's inequality</em> we get <code>Pr[X &lt; s] ≤ exp(-s/21)</code>.</p>
<p>For <code>s = 600</code> this gives <code>Pr[X &lt; s] &lt; 4·10⁻¹³</code>, and thus we end up with a great
tolerance over offline nodes and we end-up filling all the slots with tickets
with high probability.</p>
<p>For more details about threshold formula please refer to the 
<a href="https://research.web3.foundation/Polkadot/protocols/block-production/SASSAFRAS#probabilities-and-parameters">probabilities and parameters</a>
paragraph of the w3f description of the protocol.</p>
<h4 id="623-ticket-body"><a class="header" href="#623-ticket-body">6.2.3. Ticket Body</a></h4>
<p>Every candidate ticket identifier has an associated body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    TicketBody ::= SEQUENCE {
        attempt_index: U32,
        erased_pub: Ed25519PublicKey,
        revealed_pub: Ed25519PublicKey
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>attempt_index</code>: attempt index used to generate the associated <code>TicketId</code>.</li>
<li><code>erased_pub</code>: Ed25519 ephemeral public key which gets erased as soon as the
ticket is claimed.</li>
<li><code>revealed_pub</code>: Ed25519 ephemeral public key which gets exposed as soon as the
ticket is claimed.</li>
</ul>
<p>The process of generating an erased key pair is intentionally left undefined,
allowing the implementor the freedom to choose the most suitable strategy.</p>
<p>Revealed key pair is generated using bytes produced by the VRF with input
parameters equal to those employed in <code>TicketId</code> generation, only the label
is different.</p>
<p>Let <code>next_epoch</code> be an object with the information associated to the next epoch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    revealed_vrf_input = vrf_input_from_items(
        domain: BYTES(&quot;sassafras-revealed-v1.0&quot;),
        data: [ 
            next_epoch.randomness,
            BYTES(next_epoch.epoch_index),
            BYTES(attempt_index)
        ]
    );

    revealed_vrf_output = vrf_output(AUTHORITY_SECRET_KEY, revealed_vrf_input);

    revealed_seed = vrf_bytes(32, revealed_vrf_input, revealed_vrf_output);
    revealed_pub = ed25519_secret_from_seed(revealed_seed).public();
<span class="boring">}</span></code></pre></pre>
<p>The usage of the ephemeral public keys will be clarified in the ticket claiming
section (<a href="#65-claim-of-ticket-ownership-during-block-production">6.5</a>).</p>
<h4 id="624-ring-signature-production"><a class="header" href="#624-ring-signature-production">6.2.4. Ring Signature Production</a></h4>
<p><code>TicketBody</code> must be signed using the Bandersnatch ring VRF flavor (<a href="#542-ring-vrf-signature">5.4.2</a>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    sign_data = vrf_signature_data(
        transcript_label: BYTES(&quot;sassafras-ticket-body-v1.0&quot;),
        transcript_data: [
            SCALE(ticket_body)
        ],
        inputs: [
            ticket_id_vrf_input
        ]
    )
  
    ring_signature = ring_vrf_sign(RING_PROVER_KEY, sign_data)
<span class="boring">}</span></code></pre></pre>
<p><code>RING_PROVER</code> object is constructed using the authority secret key, the set
public keys which belong to the next epoch authorities and the <em>zk-SNARK</em>
context parameters (more details in the
<a href="https://github.com/w3f/ring-vrf/blob/18614458ca4cb335c88d4e710c13906a76f51e43/bandersnatch_vrfs/src/ring.rs#L91-L93">bandersnatch_vrfs</a>
reference implementation).</p>
<p>The body and the ring signature are combined in the <code>TicketEnvelope</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    TicketEnvelope ::= SEQUENCE {
        ticket_body: TicketBody,
        ring_signature: RingVrfSignature
    }   
<span class="boring">}</span></code></pre></pre>
<p>All the ticket envelopes corresponding to valid tickets are submitted on-chain
via a dedicated unsigned extrinsic.</p>
<h3 id="63-validation-of-candidate-tickets"><a class="header" href="#63-validation-of-candidate-tickets">6.3. Validation of candidate tickets</a></h3>
<p>All the actions in the steps described by this paragraph are executed by
on-chain code.</p>
<p>The tickets are received via a dedicated extrinsic call.</p>
<p>Generic validation rules:</p>
<ul>
<li>Tickets submissions must occur within the first half of the epoch.</li>
<li>For unsigned extrinsics, it must be submitted by one of the current session
validators.</li>
</ul>
<p>Ticket specific validation rules:</p>
<ul>
<li>Ring signature is verified using the on-chain <code>BandersnatchRingVerifierKey</code>.</li>
<li>Ticket identifier is locally computed from the <code>VrfOutput</code> contained in the
<code>RingVrfSignature</code> and its value is checked to be less than the ticket-threshold.</li>
</ul>
<p>Valid tickets bodies are persisted on-chain.</p>
<h3 id="64-ticket-slot-assignment"><a class="header" href="#64-ticket-slot-assignment">6.4. Ticket-Slot assignment</a></h3>
<p>Before the beginning of the next epoch, the on-chain list of tickets must be
associated with the next epoch's slots.</p>
<p>The assignment process happens in the second half of the submission epoch.</p>
<p>In the end, there must be at most one ticket per slot.</p>
<ul>
<li>Initially, the complete list of tickets is sorted based on their ticket-id,
with smaller values coming first.</li>
<li>In cases where there are more tickets than available slots, the list is pruned
by removing the larger value.</li>
<li>Tickets are then assigned to the slots using an <em>outside-in</em> assignment strategy.</li>
</ul>
<h4 id="641-outside-in-assignment"><a class="header" href="#641-outside-in-assignment">6.4.1. Outside-In Assignment</a></h4>
<p>Given an ordered sequence of tickets <code>[t0, t1, t2, ..., tk]</code> to be assigned to
<code>n</code> slots, where <code>n ≥ k</code>, the tickets are allocated according to the following
strategy:</p>
<pre><code>    slot-index  : [  0,  1,  2, ............ , n ]
    tickets     : [ t1, t3, t5, ... , t4, t2, t0 ]
</code></pre>
<p>Here <code>slot-index</code> is a relative value computed as:</p>
<pre><code>slot-index = absolute_slot_index - epoch_start_slot
</code></pre>
<p>The association between each ticket and a slot is recorded on-chain and thus
is public. What remains confidential is the identity of the ticket <em>owner</em>, and
consequently, who possesses the authority to claim the corresponding slot. This
information is known only to the author of the ticket.</p>
<h4 id="642-fallback-assignment"><a class="header" href="#642-fallback-assignment">6.4.2. Fallback Assignment</a></h4>
<p>In case the number of available tickets is less than the number of epoch slots,
some (<em>orphan</em>) slots in the middle of the epoch will remain unbounded to any
ticket.</p>
<p>In such situation, these unassigned slots are allocated using a fallback
assignment strategy.</p>
<p>The authorities registered on-chain are kept in a sorted buffer.</p>
<p>The index of the authority which has the privilege to claim an unbounded slot is
calculated as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    index_bytes = BLAKE2(4, CONCAT(epoch_randomness, BYTES(slot)));
    index = U32(index_bytes) mod authorities_number;
<span class="boring">}</span></code></pre></pre>
<h3 id="65-claim-of-ticket-ownership-during-block-production"><a class="header" href="#65-claim-of-ticket-ownership-during-block-production">6.5. Claim of ticket ownership during block production</a></h3>
<p>With tickets bound to epoch slots, every validator acquires information about
the slots for which they are supposed to produce a block.</p>
<p>The procedure for block authoring varies based on whether a given slot has an
associated ticket according to the on-chain state.</p>
<p>If a slot is associated with a ticket, we will employ the primary authoring
method. Conversely, if the slot lacks an associated ticket, we will resort to
the secondary authoring method as a fallback.</p>
<h4 id="651-primary-claim-method"><a class="header" href="#651-primary-claim-method">6.5.1. Primary Claim Method</a></h4>
<p>Let <code>ticket_body</code> represent the <code>TicketBody</code> that has been committed to the on-
chain state, <code>curr_epoch</code> denote an object containing information about the
current epoch, and <code>slot</code> represent the absolute monotonic slot number.</p>
<p>Follows the construction of <code>VrfSignatureData</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    randomness_vrf_input = vrf_input_from_items(
        domain: BYTES(&quot;sassafras-randomness-v1.0&quot;),
        data: [
            curr_epoch.randomness,
            BYTES(curr_epoch.epoch_index),
            BYTES(slot)
        ]
    );

    revealed_vrf_input = vrf_input_from_items(
        domain: BYTES(&quot;sassafras-revealed-v1.0&quot;),
        data: [
            curr_epoch.randomness,
            BYTES(curr_epoch.epoch_index),
            BYTES(ticket_body.attempt_index)
        ]
    );
    
    sign_data = vrf_signature_data(
        transcript_label: BYTES(&quot;sassafras-claim-v1.0&quot;),
        transcript_data: [
            SCALE(ticket_body)
        ],
        inputs: [
            randomness_vrf_input,
            revealed_vrf_input
        ]
    );
<span class="boring">}</span></code></pre></pre>
<p>The inclusion of <code>revealed_vrf_input</code> will generate a <code>VrfSignature</code> with a
<code>VrfOutput</code> allowing the verifier to reconstruct a <code>revealed_pub</code> key
which is expected to be equal to the one committed into the <code>TicketBody</code>.</p>
<h5 id="6511-optional-ed25519-erased-ephemeral-key-claim"><a class="header" href="#6511-optional-ed25519-erased-ephemeral-key-claim">6.5.1.1. (Optional) Ed25519 Erased Ephemeral Key Claim</a></h5>
<p>As the ticket ownership can be claimed by reconstructing the <code>revealed_pub</code>
entry of the ticket, this  step is purely optional and serves only to enforce
the claim.</p>
<TODO>
Is this step really necessary?
- Isn't better to keep it simple if this step doesn't offer any extra security?
- We already have a strong method to claim ticket ownership.
</TODO>
<p>The <em>Fiat-Shamir</em> transform is used to obtain a 32-byte challenge associated
with the <code>VrfSignData</code> transcript.</p>
<p>Validators employ the secret key associated with <code>erased_pub</code>, which has been
committed in the <code>TicketBody</code>, to sign this challenge.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    challenge = sign_data.transcript.challenge();
    erased_signature = ed25519_sign(ERASED_SECRET_KEY, challenge)
<span class="boring">}</span></code></pre></pre>
<h4 id="652-secondary-claim-method"><a class="header" href="#652-secondary-claim-method">6.5.2. Secondary Claim Method</a></h4>
<p>If the slot doesn't have any associated ticket then the validator is the one
with index equal to the rule exposed in the fallback assignment section
(<a href="#642-fallback-assignment">6.4.2</a>).</p>
<p>Given <code>randomness_vrf_input</code> constructed as shown for the primary method, the
<code>VrfSignatureData</code> is constructed as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    sign_data = vrf_signature_data(
        transcript_label: BYTES(&quot;sassafras-slot-claim-transcript-v1.0&quot;),
        transcript_data: [ ],
        inputs: [
            randomness_vrf_input
        ]
    )
<span class="boring">}</span></code></pre></pre>
<h4 id="653-slot-claim-object"><a class="header" href="#653-slot-claim-object">6.5.3. Slot Claim object</a></h4>
<p>To establish ownership of a slot, the block author must construct a <code>SlotClaim</code> object
which contains all the necessary information to assert ownership of the slot.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    SlotClaim ::= SEQUENCE {
        authority_index: U32,
        slot: U64,
        signature: VrfSignature,
        erased_signature: Ed25519Signature OPTIONAL
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p><code>authority_index</code>: index of the block author in the on-chain authorities list.</p>
</li>
<li>
<p><code>slot</code>: absolute slot number (not relative with respect to the epoch start)</p>
</li>
<li>
<p><code>signature</code>: signature that includes one or two <code>VrfOutputs</code>.</p>
<ul>
<li>The first <code>VrfOutput</code> is always present and is used to generate per-block
randomness. This is used to claim ticket ownership.</li>
<li>The second <code>VrfOutput</code> is included if the slot is associated with a ticket.
This is relevant to claim ticket ownership.</li>
</ul>
</li>
<li>
<p><code>erased_signature</code>: optional signature providing an additional proof of ticket
ownership (see 6.5.1.1).</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    signature = vrf_sign(AUTHORITY_SECRET_KEY, sign_data);

    claim = SlotClaim {
        authority_index,
        slot,
        signature,
        erased_signature
    }
<span class="boring">}</span></code></pre></pre>
<p>The <code>claim</code> object is <em>SCALE</em> encoded and sent in the block's header digest log.</p>
<h3 id="66-validation-of-the-claim-during-block-verification"><a class="header" href="#66-validation-of-the-claim-during-block-verification">6.6. Validation of the claim during block verification</a></h3>
<p>Validation of <code>SlotClaim</code> object found in the block's header.</p>
<p>The procedure depends on whether the slot has an associated ticket or not
according to the on-chain state.</p>
<p>If there is a ticket linked to the slot, the primary verification method will be
used; otherwise, the protocol resorts to the secondary one.</p>
<p>In both scenarios, the signature within the <code>SlotClaim</code> is verified using
a <code>VrfSignData</code> constructed as specified by paragraph 6.5.</p>
<p>Given <code>claim</code> an instance of <code>SlotClaim</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    public_key = AUTHORITIES[claim.authority_index];

    vrf_verify(public_key, sign_data, claim.signature);
<span class="boring">}</span></code></pre></pre>
<p>If signature verification fails then the claim is not legit.</p>
<h3 id="661-primary-claim-method-verification"><a class="header" href="#661-primary-claim-method-verification">6.6.1. Primary Claim Method Verification</a></h3>
<p>This verification is performed to confirm ticket ownership and is performed
utilizing the second <code>VrfOutput</code> contained within the <code>SlotClaim</code> <code>signature</code>.</p>
<p>By using the <code>VrfOutput</code> object together with the associated expected <code>VrfInput</code>
the verifier should be able to reconstruct the <code>revealed_pub</code> key committed in
the <code>TicketBody</code>. If there is a mismatch, the claim is not legit.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    revealed_vrf_input = vrf_input_from_items(
        domain: BYTES(&quot;sassafras-revealed-v1.0&quot;),
        data: [
            curr_epoch.randomness,
            BYTES(curr_epoch.epoch_index),
            BYTES(ticket_body.attempt_index)
        ]
    );

    reveled_vrf_output = claim.signature.outputs[1];

    revealed_seed = vrf_bytes(32, revealed_vrf_input, revealed_vrf_output);
    revealed_pub = ed25519_secret_from_seed(revealed_seed).public();

    assert(revealed_pub == ticket_body.revealed_pub);
<span class="boring">}</span></code></pre></pre>
<h5 id="6611-optional-ephemeral-key-signature-check"><a class="header" href="#6611-optional-ephemeral-key-signature-check">6.6.1.1. (Optional) Ephemeral Key Signature Check</a></h5>
<p>If the <code>erased_signature</code> element within the <code>SlotClaim</code> is present the
<code>erased_pub</code> key is used to verify it.</p>
<p>The signed challenge is generated with identical steps as outlined in section
6.5.1.1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    challenge = sign_data.transcript.challenge();
    result = ed25519_verify(ticket_body.erased_pub, challenge, claim.erased_signature);

    assert(result == true);
<span class="boring">}</span></code></pre></pre>
<h4 id="662-secondary-claim-method-verification"><a class="header" href="#662-secondary-claim-method-verification">6.6.2. Secondary Claim Method Verification</a></h4>
<p>If the slot doesn't have any associated ticket then the validator index contained in
the claim should match the one given by the rule outlined in the fallback assignment
section (<a href="#642-fallback-assignment">6.4.2</a>)</p>
<h3 id="67-randomness-accumulator"><a class="header" href="#67-randomness-accumulator">6.7. Randomness Accumulator</a></h3>
<p>The first <code>VrfOutput</code> which ships with the block's <code>SlotClaim</code> <code>signature</code>
is mandatory and must be used as the entropy source for the randomness which
gets accumulated on-chain <strong>after</strong> block processing.</p>
<p>Given <code>claim</code> the instance of <code>SlotClaim</code> within the block header, and
<code>accumulator</code> the current value for the current epoch randomness accumulator,
the <code>accumulator</code> value is updated as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    randomness_vrf_input = vrf_input_from_items(
        domain: BYTES(&quot;sassafras-randomness-v1.0&quot;),
        data: [
            curr_epoch.randomness,
            BYTES(curr_epoch.epoch_index),
            BYTES(slot)
        ]
    );

    randomness_vrf_output = claim.signature.outputs[0];

    randomness = vrf_bytes(32, randomness_vrf_input, randomness_vrf_output);

    randomness_accumulator = BLAKE2(32, CONCAT(randomness_accumulator, randomness));
<span class="boring">}</span></code></pre></pre>
<p>The updated <code>accumulator</code> value is stored on-chain.</p>
<p>The randomness accumulated during epoch <code>N</code> will be used, at the start of the
next epoch (<code>N+1</code>), as an input to compute the <code>NextEpochDescriptor</code>
<code>randomness</code> element (see section 6.1). </p>
<p>As outlined throughout the document, epoch randomness value secures various
protocol-specific functions, including ticket generation and assignment of
fallback slots (refer to section 6.4.2). Additionally, users may utilize this
value for other purposes as needed.</p>
<h2 id="7-drawbacks"><a class="header" href="#7-drawbacks">7. Drawbacks</a></h2>
<p>None</p>
<h2 id="8-testing-security-and-privacy"><a class="header" href="#8-testing-security-and-privacy">8. Testing, Security, and Privacy</a></h2>
<p>The reference implementation for this RFC will be tested on testnets first.</p>
<p>An audit may be required to ensure the implementation does not introduce unwanted side effects</p>
<h2 id="9-performance-ergonomics-and-compatibility"><a class="header" href="#9-performance-ergonomics-and-compatibility">9. Performance, Ergonomics, and Compatibility</a></h2>
<h3 id="91-performance"><a class="header" href="#91-performance">9.1. Performance</a></h3>
<p>The utilization of Sassafras consensus represents a significant advancement in
the mitigation of short-lived fork occurrences.</p>
<p>Generation of forks are not possible when following the protocol and the only source
of forks is network partitioning. In this case, on recovery, the decision of
which fork to follow is not opinionated and there is only one choice.</p>
<h3 id="92-ergonomics"><a class="header" href="#92-ergonomics">9.2. Ergonomics</a></h3>
<p>No specific considerations.</p>
<h3 id="93-compatibility"><a class="header" href="#93-compatibility">9.3. Compatibility</a></h3>
<p>The adoption of Sassafras impacts native client code and thus can't be
introduced via a simple runtime upgrade.</p>
<p>A deployment strategy should be carefully engineered for live networks.</p>
<p>This subject is left open for a dedicated RFC.</p>
<h2 id="10-prior-art-and-references"><a class="header" href="#10-prior-art-and-references">10. Prior Art and References</a></h2>
<ul>
<li>Web3 Foundation research page: https://research.web3.foundation/Polkadot/protocols/block-production/SASSAFRAS</li>
<li>Sassafras whitepaper: https://eprint.iacr.org/2023/031.pdf</li>
<li>Ring-VRF whitepaper: https://eprint.iacr.org/2023/002.pdf</li>
<li>Sassafras reference implementation tracking issue: https://github.com/paritytech/substrate/issues/11515</li>
<li>Sassafras reference implementation main PR: https://github.com/paritytech/substrate/pull/11879</li>
</ul>
<h2 id="11-unresolved-questions"><a class="header" href="#11-unresolved-questions">11. Unresolved Questions</a></h2>
<p>None</p>
<h2 id="12-future-directions-and-related-material"><a class="header" href="#12-future-directions-and-related-material">12. Future Directions and Related Material</a></h2>
<p>While this RFC lays the groundwork and outlines the core aspects of the
protocol, several crucial topics remain to be addressed in future RFCs to ensure
the protocol's completeness and security.</p>
<p>These topics include:</p>
<h3 id="121-interactions-with-the-runtime"><a class="header" href="#121-interactions-with-the-runtime">12.1. Interactions with the Runtime</a></h3>
<ul>
<li>
<p><strong>Outbound Interface</strong>. Interfaces exposed by the host which are required by the runtime.
These are commonly dubbed <em>Host Functions</em>.</p>
</li>
<li>
<p><strong>Unrecorded Inbound Interfaces</strong>. Interfaces exposed by the runtime which are required by the host.
These are commonly dubbed <em>Runtime APIs</em>.</p>
</li>
<li>
<p><strong>Transactional Inbound Interfaces</strong>. Interfaces exposed by the runtime which alter the state.
These are commonly dubbed <em>Extrinsics</em> and <em>Inherents</em>.</p>
</li>
</ul>
<h3 id="122-deployment-strategies"><a class="header" href="#122-deployment-strategies">12.2. Deployment Strategies</a></h3>
<ul>
<li><strong>Protocol Migration</strong>. Exploring how this protocol can seamlessly replace
an already operational instance of another protocol is essential. Future RFCs
should delve into the deployment strategy, including considerations for a smooth
transition process.</li>
</ul>
<h3 id="123-zk-snark-srs-initialization-ceremony"><a class="header" href="#123-zk-snark-srs-initialization-ceremony">12.3. ZK-SNARK SRS Initialization Ceremony.</a></h3>
<ul>
<li>
<p><strong>Timing and Procedure</strong>: Determining the timing and procedure for the ZK-SNARK
SRS (Structured Reference String) initialization ceremony. Future RFCs should
provide insights into whether this process should be performed before the
deployment of Sassafras and the steps involved.</p>
</li>
<li>
<p><strong>Sharing with Para-chains</strong>: Considering the complexity of the ceremony, we
must understand whether the SRS is shared with para-chains or maintained
independently.</p>
</li>
</ul>
<h3 id="124-anonymous-submission-of-tickets"><a class="header" href="#124-anonymous-submission-of-tickets">12.4. Anonymous Submission of Tickets.</a></h3>
<ul>
<li><strong>Mixnet Integration</strong>: Submitting tickets directly can pose a risk of
potential deanonymization through traffic analysis. Subsequent RFCs should
investigate the potential for incorporating Mixnet technology or other
privacy-enhancing mechanisms to address this concern.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../proposed/0020-treasurer-track-confirmation-period-duration-modification.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../proposed/0034-xcm-absolute-location-account-derivation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../proposed/0020-treasurer-track-confirmation-period-duration-modification.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../proposed/0034-xcm-absolute-location-account-derivation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
